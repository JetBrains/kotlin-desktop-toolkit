package org.jetbrains.desktop.macos

import org.jetbrains.desktop.macos.generated.NativeApplicationAppearanceChangeEvent
import org.jetbrains.desktop.macos.generated.NativeApplicationOpenUrlsEvent
import org.jetbrains.desktop.macos.generated.NativeEvent
import org.jetbrains.desktop.macos.generated.NativeKeyDownEvent
import org.jetbrains.desktop.macos.generated.NativeKeyUpEvent
import org.jetbrains.desktop.macos.generated.NativeModifiersChangedEvent
import org.jetbrains.desktop.macos.generated.NativeMouseDownEvent
import org.jetbrains.desktop.macos.generated.NativeMouseDraggedEvent
import org.jetbrains.desktop.macos.generated.NativeMouseEnteredEvent
import org.jetbrains.desktop.macos.generated.NativeMouseExitedEvent
import org.jetbrains.desktop.macos.generated.NativeMouseMovedEvent
import org.jetbrains.desktop.macos.generated.NativeMouseUpEvent
import org.jetbrains.desktop.macos.generated.NativeScrollWheelEvent
import org.jetbrains.desktop.macos.generated.NativeWindowChangedOcclusionStateEvent
import org.jetbrains.desktop.macos.generated.NativeWindowCloseRequestEvent
import org.jetbrains.desktop.macos.generated.NativeWindowFocusChangeEvent
import org.jetbrains.desktop.macos.generated.NativeWindowFullScreenToggleEvent
import org.jetbrains.desktop.macos.generated.NativeWindowMoveEvent
import org.jetbrains.desktop.macos.generated.NativeWindowResizeEvent
import org.jetbrains.desktop.macos.generated.NativeWindowScreenChangeEvent
import org.jetbrains.desktop.macos.generated.desktop_macos_h
import java.lang.foreign.Arena
import java.lang.foreign.MemorySegment
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

@JvmInline
public value class Timestamp(
    // Count of seconds passed since some fixed but arbitrary moment in the past
    private val value: Double,
) {
    public fun toDuration(): Duration {
        return value.seconds
    }
}

public interface WindowEvent {
    public val windowId: WindowId
}

public sealed class Event {
    public companion object {
        /**
         * Be aware this might be inacurate, namely:
         * When you enable tap to click and tap on external track pad
         * this set might be immidiately empty, even though we are handling
         * key down event.
         */
        public fun pressedMouseButtons(): MouseButtonsSet {
            return MouseButtonsSet(ffiDownCall { desktop_macos_h.events_pressed_mouse_buttons() })
        }

        /**
         * It's also might be inconsistent, e.g. in the following case:
         * 0. We alt tab to a window
         * 0. Press modifier
         * 1. Window gains focus
         * 2. We expect that the pressed modifier will be counted in this state, but it's apparently not
         * 3. We didn't get any modifiers changed event
         */
        public fun pressedModifiers(): KeyModifiersSet {
            return KeyModifiersSet(ffiDownCall { desktop_macos_h.events_pressed_modifiers() })
        }

        public fun cursorLocationInScreen(): LogicalPoint {
            return Arena.ofConfined().use { arena ->
                LogicalPoint.fromNative(ffiDownCall { desktop_macos_h.events_cursor_location_in_screen(arena) })
            }
        }

        /**
         * Returns characters that would be generated by the current key event
         * if the specified modifier flags were applied instead of the actual modifier flags.
         * apple doc: https://developer.apple.com/documentation/appkit/nsevent/characters(byapplyingmodifiers:)?language=objc
         * For more details see [KeyDown]
         *
         * Must be called during key event handling.
         * @throws NativeError if called outside of an event handler.
         * @return characters that would be generated if modifiers pressed
         */
        public fun charactersByApplyingModifiersForCurrentEvent(modifiers: KeyModifiersSet): Characters {
            var result: MemorySegment = MemorySegment.NULL
            return try {
                result = ffiDownCall { desktop_macos_h.events_characters_by_applying_modifiers(modifiers.value) }
                Characters(result.getUtf8String(0))
            } finally {
                if (result != MemorySegment.NULL) {
                    ffiDownCall { desktop_macos_h.string_drop(result) }
                    result = MemorySegment.NULL
                }
            }
        }
    }

    /**
     * Thesaurus:
     *
     * Keyboard type: The physical layout of the keyboard, ANSI, ISO, or JIS
     *
     * Text input source: way of entering text chosen in OS
     * it's either a keyboard layout e.g., ABC, Russian, German or input method e.g., Japanese
     *
     * Modifiers: buttons like Shift, Command, Control, Option, etc.
     *
     * @param keyCode is a physical location of the key.
     * Some keyCodes are available only on JIS or ISO keyboards.
     * Based on the keyboard type, the same keyCode might produce different characters,
     * e.g., ANSI_LeftBracket produces `[` with ANSI keyboard and `@` with JIS keyboard, even with the ABC input source selected.
     *
     * @param characters apple doc: https://developer.apple.com/documentation/appkit/nsevent/characters?language=objc
     * Roughly speaking, it's a value that we expect to be typed with this key event (not taking into account IME state?).
     * It depends on the keyboard type, selected input source, and pressed modifiers.
     * For keys like F1-F12 or arrow keys [SpecialKey] will be produced.
     * For some keys like Enter or Escape [SpecialCharacter] will be produced.
     * For dead keys the empty string will be produced.
     *
     * @param charactersIgnoringModifiers apple doc: https://developer.apple.com/documentation/appkit/nsevent/charactersignoringmodifiers?language=objc
     * It's a value that we expect to be typed with this key event, ignoring pressed modifiers.
     * It depends on the keyboard type, selected input source, and Shift modifier.
     * Regarding [SpecialKey] and [SpecialCharacter] behave the same as [characters].
     * The main issue is that it is still affected by Shift (and maybe by some other modifiers we have to check), so it's hard to use
     * as a source of truth for keystroke processing.
     *
     * @param modifiers apple doc: https://developer.apple.com/documentation/appkit/nsevent/modifierflags?language=objc
     * A set of flags that indicate which modifier keys are currently pressed.
     * Shift, Command, Control, Option behave as expected,
     * but other modifiers like CapsLock, NumLock, Function, and Help have slightly weird meaning.
     * For example, every key press of F-key will have the function modifier set.
     *
     * @param isRepeat apple doc: https://developer.apple.com/documentation/appkit/nsevent/isarepeat?language=objc
     * A Boolean value that indicates whether the key event is a repeat of a previous key event.
     *
     * @param mightHaveKeyEquivalent
     * True for events that macOS considers as potential keystrokes (it should include Command or Control),
     *
     * @param timestamp apple doc: https://developer.apple.com/documentation/appkit/nsevent/timestamp?language=objc
     * The time at which the event occurred, measured in seconds since the epoch.
     *
     * @param key
     * The value is obtained by calling [Event.charactersByApplyingModifiersForCurrentEvent] with empty modifiers.
     * It depends on the keyboard type, selected input source, but not on modifiers pressed.
     * In this regard it's similar to [charactersIgnoringModifiers] with the following difference:
     * - It's not affected by the Shift modifier
     * - For dead keys it produces text from the default layer
     * - For keys like F1-F12 it produces U+0010
     * - And for some keys like Enter or Escape it produces codepoints form [SpecialCharacter], but not from [SpecialKey]
     *
     * @param keyWithModifiers
     * The value is obtained by calling [Event.charactersByApplyingModifiersForCurrentEvent] with modifiers pressed.
     * It depends on the keyboard type, selected input source, and pressed modifiers.
     * In general, it behaves the same way as [key]
     * Main difference from [characters] that for dead keys it produces text from the default layer.
     */
    public data class KeyDown(
        override val windowId: WindowId,
        val keyCode: KeyCode,
        val characters: Characters,
        val charactersIgnoringModifiers: Characters,
        val modifiers: KeyModifiersSet,
        val isRepeat: Boolean,
        val mightHaveKeyEquivalent: Boolean,
        val timestamp: Timestamp,

        val key: Characters,
        val keyWithModifiers: Characters,
    ) : Event(),
        WindowEvent

    /**
     * See [KeyDown] for documentation
     */
    public data class KeyUp(
        override val windowId: WindowId,
        val keyCode: KeyCode,
        val characters: Characters,
        val charactersIgnoringModifiers: Characters,
        val modifiers: KeyModifiersSet,
        val timestamp: Timestamp,

        val key: Characters,
        val keyWithModifiers: Characters,
    ) : Event(),
        WindowEvent

    public data class ModifiersChanged(
        override val windowId: WindowId,
        val modifiers: KeyModifiersSet,
        val keyCode: KeyCode,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseMoved(
        override val windowId: WindowId,
        val locationInWindow: LogicalPoint,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseDragged(
        override val windowId: WindowId,
        val button: MouseButton,
        val locationInWindow: LogicalPoint,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseEntered(
        override val windowId: WindowId,
        val locationInWindow: LogicalPoint,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseExited(
        override val windowId: WindowId,
        val locationInWindow: LogicalPoint,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseUp(
        override val windowId: WindowId,
        val button: MouseButton,
        val locationInWindow: LogicalPoint,
        val clickCount: Long,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class MouseDown(
        override val windowId: WindowId,
        val button: MouseButton,
        val locationInWindow: LogicalPoint,
        val clickCount: Long,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class ScrollWheel(
        override val windowId: WindowId,
        val scrollingDeltaX: LogicalPixels,
        val scrollingDeltaY: LogicalPixels,
        val hasPreciseScrillingDeltas: Boolean,
        val isDirectionInverted: Boolean,
        val locationInWindow: LogicalPoint,
        val timestamp: Timestamp,
    ) : Event(),
        WindowEvent

    public data class WindowScreenChange(
        override val windowId: WindowId,
        val newScreenId: ScreenId,
    ) : Event(),
        WindowEvent

    public data class WindowResize(
        override val windowId: WindowId,
        val size: LogicalSize,
    ) : Event(),
        WindowEvent

    public data class WindowMove(
        override val windowId: WindowId,
        val origin: LogicalPoint,
    ) : Event(),
        WindowEvent

    public data class WindowFocusChange(
        override val windowId: WindowId,
        val isKeyWindow: Boolean,
        val isMainWindow: Boolean,
    ) : Event(),
        WindowEvent

    public data class WindowFullScreenToggle(
        override val windowId: WindowId,
        val isFullScreen: Boolean,
    ) : Event(),
        WindowEvent

    public data class WindowChangedOcclusionState(
        override val windowId: WindowId,
        val isVisible: Boolean,
    ) : Event(),
        WindowEvent

    public data object DisplayConfigurationChange : Event()

    public data object ApplicationDidFinishLaunching : Event()

    public data class ApplicationOpenUrls(val urls: List<String>) : Event()

    public data class WindowCloseRequest(override val windowId: WindowId) :
        Event(),
        WindowEvent

    public data class ApplicationAppearanceChange(val newAppearance: Appearance) : Event()
}

internal fun Event.Companion.fromNative(s: MemorySegment): Event {
    return when (NativeEvent.tag(s)) {
        desktop_macos_h.NativeEvent_KeyDown() -> {
            val nativeEvent = NativeEvent.key_down(s)
            val modifiers = KeyModifiersSet(NativeKeyDownEvent.modifiers(nativeEvent))
            Event.KeyDown(
                windowId = NativeKeyDownEvent.window_id(nativeEvent),
                keyCode = KeyCode.fromNative(NativeKeyDownEvent.code(nativeEvent)),
                characters = Characters(NativeKeyDownEvent.characters(nativeEvent).getUtf8String(0)),
                key = Event.charactersByApplyingModifiersForCurrentEvent(KeyModifiersSet.create()),
                keyWithModifiers = Event.charactersByApplyingModifiersForCurrentEvent(modifiers),
                charactersIgnoringModifiers = Characters(NativeKeyDownEvent.characters_ignoring_modifiers(nativeEvent).getUtf8String(0)),
                modifiers = modifiers,
                isRepeat = NativeKeyDownEvent.is_repeat(nativeEvent),
                mightHaveKeyEquivalent = NativeKeyDownEvent.might_have_key_equivalent(nativeEvent),
                timestamp = Timestamp(NativeKeyDownEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_KeyUp() -> {
            val nativeEvent = NativeEvent.key_up(s)
            val modifiers = KeyModifiersSet(NativeKeyUpEvent.modifiers(nativeEvent))
            Event.KeyUp(
                windowId = NativeKeyUpEvent.window_id(nativeEvent),
                characters = Characters(NativeKeyUpEvent.characters(nativeEvent).getUtf8String(0)),
                key = Event.charactersByApplyingModifiersForCurrentEvent(KeyModifiersSet.create()),
                keyWithModifiers = Event.charactersByApplyingModifiersForCurrentEvent(modifiers),
                charactersIgnoringModifiers = Characters(NativeKeyUpEvent.characters_ignoring_modifiers(nativeEvent).getUtf8String(0)),
                modifiers = modifiers,
                keyCode = KeyCode.fromNative(NativeKeyUpEvent.code(nativeEvent)),
                timestamp = Timestamp(NativeKeyUpEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_ModifiersChanged() -> {
            val nativeEvent = NativeEvent.modifiers_changed(s)
            Event.ModifiersChanged(
                windowId = NativeModifiersChangedEvent.window_id(nativeEvent),
                modifiers = KeyModifiersSet(NativeModifiersChangedEvent.modifiers(nativeEvent)),
                keyCode = KeyCode.fromNative(NativeModifiersChangedEvent.code(nativeEvent)),
                timestamp = Timestamp(NativeModifiersChangedEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseMoved() -> {
            val nativeEvent = NativeEvent.mouse_moved(s)
            Event.MouseMoved(
                windowId = NativeMouseMovedEvent.window_id(nativeEvent),
                locationInWindow = LogicalPoint.fromNative(NativeMouseMovedEvent.location_in_window(nativeEvent)),
                timestamp = Timestamp(NativeMouseMovedEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseDragged() -> {
            val nativeEvent = NativeEvent.mouse_dragged(s)
            Event.MouseDragged(
                windowId = NativeMouseDraggedEvent.window_id(nativeEvent),
                button = MouseButton(NativeMouseDraggedEvent.button(nativeEvent)),
                locationInWindow = LogicalPoint.fromNative(NativeMouseDraggedEvent.location_in_window(nativeEvent)),
                timestamp = Timestamp(NativeMouseDraggedEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseEntered() -> {
            val nativeEvent = NativeEvent.mouse_entered(s)
            Event.MouseEntered(
                windowId = NativeMouseEnteredEvent.window_id(nativeEvent),
                locationInWindow = LogicalPoint.fromNative(NativeMouseEnteredEvent.location_in_window(nativeEvent)),
                timestamp = Timestamp(NativeMouseEnteredEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseExited() -> {
            val nativeEvent = NativeEvent.mouse_exited(s)
            Event.MouseExited(
                windowId = NativeMouseExitedEvent.window_id(nativeEvent),
                locationInWindow = LogicalPoint.fromNative(NativeMouseExitedEvent.location_in_window(nativeEvent)),
                timestamp = Timestamp(NativeMouseExitedEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseUp() -> {
            val nativeEvent = NativeEvent.mouse_up(s)
            Event.MouseUp(
                windowId = NativeMouseUpEvent.window_id(nativeEvent),
                button = MouseButton(NativeMouseUpEvent.button(nativeEvent)),
                locationInWindow = LogicalPoint.fromNative(NativeMouseUpEvent.location_in_window(nativeEvent)),
                clickCount = NativeMouseUpEvent.click_count(nativeEvent),
                timestamp = Timestamp(NativeMouseUpEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_MouseDown() -> {
            val nativeEvent = NativeEvent.mouse_down(s)
            Event.MouseDown(
                windowId = NativeMouseDownEvent.window_id(nativeEvent),
                button = MouseButton(NativeMouseDownEvent.button(nativeEvent)),
                locationInWindow = LogicalPoint.fromNative(NativeMouseDownEvent.location_in_window(nativeEvent)),
                clickCount = NativeMouseUpEvent.click_count(nativeEvent),
                timestamp = Timestamp(NativeMouseDownEvent.timestamp(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_ScrollWheel() -> {
            val nativeEvent = NativeEvent.scroll_wheel(s)
            Event.ScrollWheel(
                windowId = NativeScrollWheelEvent.window_id(nativeEvent),
                scrollingDeltaX = NativeScrollWheelEvent.scrolling_delta_x(nativeEvent),
                scrollingDeltaY = NativeScrollWheelEvent.scrolling_delta_y(nativeEvent),
                hasPreciseScrillingDeltas = NativeScrollWheelEvent.has_precise_scrolling_deltas(nativeEvent),
                isDirectionInverted = NativeScrollWheelEvent.is_direction_inverted(nativeEvent),
                locationInWindow = LogicalPoint.fromNative(NativeScrollWheelEvent.location_in_window(nativeEvent)),
                timestamp = Timestamp(NativeScrollWheelEvent.timestamp(nativeEvent)),
            )
        } desktop_macos_h.NativeEvent_WindowScreenChange() -> {
            val nativeEvent = NativeEvent.window_screen_change(s)
            Event.WindowScreenChange(
                windowId = NativeWindowScreenChangeEvent.window_id(nativeEvent),
                newScreenId = NativeWindowScreenChangeEvent.new_screen_id(nativeEvent),
            )
        }
        desktop_macos_h.NativeEvent_WindowResize() -> {
            val nativeEvent = NativeEvent.window_resize(s)
            Event.WindowResize(
                windowId = NativeWindowResizeEvent.window_id(nativeEvent),
                size = LogicalSize.fromNative(NativeWindowResizeEvent.size(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_WindowMove() -> {
            val nativeEvent = NativeEvent.window_move(s)
            Event.WindowMove(
                windowId = NativeWindowMoveEvent.window_id(nativeEvent),
                origin = LogicalPoint.fromNative(NativeWindowMoveEvent.origin(nativeEvent)),
            )
        }
        desktop_macos_h.NativeEvent_WindowFocusChange() -> {
            val nativeEvent = NativeEvent.window_focus_change(s)
            Event.WindowFocusChange(
                windowId = NativeWindowFocusChangeEvent.window_id(nativeEvent),
                isKeyWindow = NativeWindowFocusChangeEvent.is_key(nativeEvent),
                isMainWindow = NativeWindowFocusChangeEvent.is_main(nativeEvent),
            )
        }
        desktop_macos_h.NativeEvent_WindowCloseRequest() -> {
            val nativeEvent = NativeEvent.window_close_request(s)
            Event.WindowCloseRequest(
                windowId = NativeWindowCloseRequestEvent.window_id(nativeEvent),
            )
        }
        desktop_macos_h.NativeEvent_DisplayConfigurationChange() -> {
            Event.DisplayConfigurationChange
        }
        desktop_macos_h.NativeEvent_ApplicationOpenUrls() -> {
            val nativeEvent = NativeEvent.application_open_urls(s)
            val urlsArray = NativeApplicationOpenUrlsEvent.urls(nativeEvent)
            Event.ApplicationOpenUrls(listOfStringsFromNative(urlsArray))
        }
        desktop_macos_h.NativeEvent_ApplicationDidFinishLaunching() -> {
            Event.ApplicationDidFinishLaunching
        }
        desktop_macos_h.NativeEvent_WindowFullScreenToggle() -> {
            val nativeEvent = NativeEvent.window_full_screen_toggle(s)
            Event.WindowFullScreenToggle(
                windowId = NativeWindowFullScreenToggleEvent.window_id(nativeEvent),
                isFullScreen = NativeWindowFullScreenToggleEvent.is_full_screen(nativeEvent),
            )
        }
        desktop_macos_h.NativeEvent_WindowChangedOcclusionState() -> {
            val nativeEvent = NativeEvent.window_changed_occlusion_state(s)
            Event.WindowChangedOcclusionState(
                windowId = NativeWindowChangedOcclusionStateEvent.window_id(nativeEvent),
                isVisible = NativeWindowChangedOcclusionStateEvent.is_visible(nativeEvent),
            )
        }
        desktop_macos_h.NativeEvent_ApplicationAppearanceChange() -> {
            val nativeEvent = NativeEvent.application_appearance_change(s)
            Event.ApplicationAppearanceChange(
                newAppearance = Appearance.fromNative(NativeApplicationAppearanceChangeEvent.new_appearance(nativeEvent)),
            )
        }
        else -> {
            error("Unexpected Event tag")
        }
    }
}
