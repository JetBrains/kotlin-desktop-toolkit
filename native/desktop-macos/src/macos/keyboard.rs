use anyhow::{Context, Ok, bail};
use bitflags::Flags;
use objc2::rc::Retained;
use objc2_app_kit::{NSEvent, NSEventModifierFlags, NSEventType};
use objc2_foundation::NSString;

#[repr(transparent)]
#[derive(Debug, Clone, Copy)]
pub struct KeyCode(pub u16);

#[derive(Debug)]
pub(crate) struct KeyEventInfo {
    pub(crate) is_repeat: bool,

    // Represents physical key location
    // Isn't affected by keyboard layout, locale and pressed modifiers
    pub(crate) code: KeyCode,

    // Roughly speaking it's a text that will be generated by this key press.
    // It's affected by keyboard layout locale and pressed modifiers.
    // It may contain codepoint constants listed in this file,
    // e.g. for F1 it will be value of `NSF1FunctionKey` constant.
    // For dead keys it will be empty.
    pub(crate) chars: Retained<NSString>,

    // Can be considered as a name of the key
    // Depends on keyboard layout but ignores modifiers
    // For keys that depend on keyboard layout it will be the symbol typed for default layer
    // For functional keys it will try to produce some meaningful codepoint, but not the same as for `characters`
    // For dead keys it will produce text from deafult layer
    #[allow(dead_code)]
    pub(crate) key: Retained<NSString>,

    pub(crate) modifiers: KeyModifiersSet,
}

pub(crate) fn unpack_key_event(ns_event: &NSEvent) -> anyhow::Result<KeyEventInfo> {
    let is_repeat = unsafe { ns_event.isARepeat() };
    let code = unsafe { ns_event.keyCode() };

    let chars = unsafe { ns_event.characters() }.with_context(|| format!("No characters field in {ns_event:?}"))?;

    let key = unsafe { ns_event.charactersByApplyingModifiers(NSEventModifierFlags::empty()) }
        .with_context(|| format!("Event contains invalid data: {ns_event:?}"))?;

    // though we apply the same modifiers, it's not the same as characters
    // there are number of differences:
    // * for dead keys `characters` will be empty, but this string will contain symbol representing the key
    // * for for keys like F1..F12 characters will contain codepoints from private use area defined in `KeyCodePoints`,
    // but this function will try to return some meaniingful code points
    // * for all F1..F16 keys this function will return the same codepoint: \u{10} for F17 it will be empty line
    //let _with_modifiers = unsafe {
    //    ns_event.charactersByApplyingModifiers(ns_event.modifierFlags())
    //}.with_context(|| { format!("Event contains invalid data: {ns_event:?}") })?;
    let modifiers = unsafe { ns_event.modifierFlags() }.into();

    let key_info = KeyEventInfo {
        is_repeat,
        code: KeyCode(code),
        chars,
        key,
        modifiers,
    };
    Ok(key_info)
}

#[derive(Debug)]
pub(crate) struct FlagsChangedInfo {
    pub(crate) modifiers: KeyModifiersSet,
    pub(crate) code: KeyCode,
}

pub(crate) fn unpack_flags_changed_event(ns_event: &NSEvent) -> anyhow::Result<FlagsChangedInfo> {
    if unsafe { ns_event.r#type() } != NSEventType::FlagsChanged {
        bail!("Unexpected type of event {:?}", ns_event);
    }
    let modifiers = unsafe { ns_event.modifierFlags() }.into();
    let code = unsafe { ns_event.keyCode() };

    Ok(FlagsChangedInfo {
        modifiers,
        code: KeyCode(code),
    })
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct KeyModifiersSet(pub usize);

impl std::fmt::Debug for KeyModifiersSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyModifiersSet({:032b})", self.0)
    }
}

impl KeyModifiersSet {
    #[must_use]
    pub const fn contains(&self, flag: usize) -> bool {
        self.0 & flag == flag
    }
}

pub(crate) const EMPTY_KEY_MODIFIERS: KeyModifiersSet = KeyModifiersSet(0);

impl From<NSEventModifierFlags> for KeyModifiersSet {
    fn from(value: NSEventModifierFlags) -> Self {
        // We filter out device dependant part of modifier flags
        // It contains e.g. flags that allow to distinct between left and right modifier keys
        // But I'm not sure that it has the same meaning for Intel, or for different keyboars
        Self(value.bits() & NSEventModifierFlags::DeviceIndependentFlagsMask.bits())
    }
}

impl From<KeyModifiersSet> for NSEventModifierFlags {
    fn from(value: KeyModifiersSet) -> Self {
        Self(value.0)
    }
}

/*  MacOSX15.2
 *  Summary:
 *    Virtual keycodes
 *
 *  Discussion:
 *    These constants are the virtual keycodes defined originally in
 *    Inside Mac Volume V, pg. V-191. They identify physical keys on a
 *    keyboard. Those constants with "ANSI" in the name are labeled
 *    according to the key position on an ANSI-standard US keyboard.
 *    For example, kVK_ANSI_A indicates the virtual keycode for the key
 *    with the letter 'A' in the US keyboard layout. Other keyboard
 *    layouts may have the 'A' key label on a different physical key;
 *    in this case, pressing 'A' will generate a different virtual
 *    keycode.
 */
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
pub mod key_codes {
    pub(crate) const VK_ANSI_A: u16 = 0x00;
    pub(crate) const VK_ANSI_S: u16 = 0x01;
    pub(crate) const VK_ANSI_D: u16 = 0x02;
    pub(crate) const VK_ANSI_F: u16 = 0x03;
    pub(crate) const VK_ANSI_H: u16 = 0x04;
    pub(crate) const VK_ANSI_G: u16 = 0x05;
    pub(crate) const VK_ANSI_Z: u16 = 0x06;
    pub(crate) const VK_ANSI_X: u16 = 0x07;
    pub(crate) const VK_ANSI_C: u16 = 0x08;
    pub(crate) const VK_ANSI_V: u16 = 0x09;
    pub(crate) const VK_ANSI_B: u16 = 0x0B;
    pub(crate) const VK_ANSI_Q: u16 = 0x0C;
    pub(crate) const VK_ANSI_W: u16 = 0x0D;
    pub(crate) const VK_ANSI_E: u16 = 0x0E;
    pub(crate) const VK_ANSI_R: u16 = 0x0F;
    pub(crate) const VK_ANSI_Y: u16 = 0x10;
    pub(crate) const VK_ANSI_T: u16 = 0x11;
    pub(crate) const VK_ANSI_1: u16 = 0x12;
    pub(crate) const VK_ANSI_2: u16 = 0x13;
    pub(crate) const VK_ANSI_3: u16 = 0x14;
    pub(crate) const VK_ANSI_4: u16 = 0x15;
    pub(crate) const VK_ANSI_6: u16 = 0x16;
    pub(crate) const VK_ANSI_5: u16 = 0x17;
    pub(crate) const VK_ANSI_Equal: u16 = 0x18;
    pub(crate) const VK_ANSI_9: u16 = 0x19;
    pub(crate) const VK_ANSI_7: u16 = 0x1A;
    pub(crate) const VK_ANSI_Minus: u16 = 0x1B;
    pub(crate) const VK_ANSI_8: u16 = 0x1C;
    pub(crate) const VK_ANSI_0: u16 = 0x1D;
    pub(crate) const VK_ANSI_RightBracket: u16 = 0x1E;
    pub(crate) const VK_ANSI_O: u16 = 0x1F;
    pub(crate) const VK_ANSI_U: u16 = 0x20;
    pub(crate) const VK_ANSI_LeftBracket: u16 = 0x21;
    pub(crate) const VK_ANSI_I: u16 = 0x22;
    pub(crate) const VK_ANSI_P: u16 = 0x23;
    pub(crate) const VK_ANSI_L: u16 = 0x25;
    pub(crate) const VK_ANSI_J: u16 = 0x26;
    pub(crate) const VK_ANSI_Quote: u16 = 0x27;
    pub(crate) const VK_ANSI_K: u16 = 0x28;
    pub(crate) const VK_ANSI_Semicolon: u16 = 0x29;
    pub(crate) const VK_ANSI_Backslash: u16 = 0x2A;
    pub(crate) const VK_ANSI_Comma: u16 = 0x2B;
    pub(crate) const VK_ANSI_Slash: u16 = 0x2C;
    pub(crate) const VK_ANSI_N: u16 = 0x2D;
    pub(crate) const VK_ANSI_M: u16 = 0x2E;
    pub(crate) const VK_ANSI_Period: u16 = 0x2F;
    pub(crate) const VK_ANSI_Grave: u16 = 0x32;
    pub(crate) const VK_ANSI_KeypadDecimal: u16 = 0x41;
    pub(crate) const VK_ANSI_KeypadMultiply: u16 = 0x43;
    pub(crate) const VK_ANSI_KeypadPlus: u16 = 0x45;
    pub(crate) const VK_ANSI_KeypadClear: u16 = 0x47;
    pub(crate) const VK_ANSI_KeypadDivide: u16 = 0x4B;
    pub(crate) const VK_ANSI_KeypadEnter: u16 = 0x4C;
    pub(crate) const VK_ANSI_KeypadMinus: u16 = 0x4E;
    pub(crate) const VK_ANSI_KeypadEquals: u16 = 0x51;
    pub(crate) const VK_ANSI_Keypad0: u16 = 0x52;
    pub(crate) const VK_ANSI_Keypad1: u16 = 0x53;
    pub(crate) const VK_ANSI_Keypad2: u16 = 0x54;
    pub(crate) const VK_ANSI_Keypad3: u16 = 0x55;
    pub(crate) const VK_ANSI_Keypad4: u16 = 0x56;
    pub(crate) const VK_ANSI_Keypad5: u16 = 0x57;
    pub(crate) const VK_ANSI_Keypad6: u16 = 0x58;
    pub(crate) const VK_ANSI_Keypad7: u16 = 0x59;
    pub(crate) const VK_ANSI_Keypad8: u16 = 0x5B;
    pub(crate) const VK_ANSI_Keypad9: u16 = 0x5C;

    /* keycodes for keys that are independent of keyboard layout*/
    pub(crate) const VK_Return: u16 = 0x24;
    pub(crate) const VK_Tab: u16 = 0x30;
    pub(crate) const VK_Space: u16 = 0x31;
    pub(crate) const VK_Delete: u16 = 0x33;
    pub(crate) const VK_Escape: u16 = 0x35;
    pub(crate) const VK_Command: u16 = 0x37;
    pub(crate) const VK_Shift: u16 = 0x38;
    pub(crate) const VK_CapsLock: u16 = 0x39;
    pub(crate) const VK_Option: u16 = 0x3A;
    pub(crate) const VK_Control: u16 = 0x3B;
    pub(crate) const VK_RightCommand: u16 = 0x36;
    pub(crate) const VK_RightShift: u16 = 0x3C;
    pub(crate) const VK_RightOption: u16 = 0x3D;
    pub(crate) const VK_RightControl: u16 = 0x3E;
    pub(crate) const VK_Function: u16 = 0x3F;
    pub(crate) const VK_F17: u16 = 0x40;
    pub(crate) const VK_VolumeUp: u16 = 0x48;
    pub(crate) const VK_VolumeDown: u16 = 0x49;
    pub(crate) const VK_Mute: u16 = 0x4A;
    pub(crate) const VK_F18: u16 = 0x4F;
    pub(crate) const VK_F19: u16 = 0x50;
    pub(crate) const VK_F20: u16 = 0x5A;
    pub(crate) const VK_F5: u16 = 0x60;
    pub(crate) const VK_F6: u16 = 0x61;
    pub(crate) const VK_F7: u16 = 0x62;
    pub(crate) const VK_F3: u16 = 0x63;
    pub(crate) const VK_F8: u16 = 0x64;
    pub(crate) const VK_F9: u16 = 0x65;
    pub(crate) const VK_F11: u16 = 0x67;
    pub(crate) const VK_F13: u16 = 0x69;
    pub(crate) const VK_F16: u16 = 0x6A;
    pub(crate) const VK_F14: u16 = 0x6B;
    pub(crate) const VK_F10: u16 = 0x6D;
    pub(crate) const VK_ContextualMenu: u16 = 0x6E;
    pub(crate) const VK_F12: u16 = 0x6F;
    pub(crate) const VK_F15: u16 = 0x71;
    pub(crate) const VK_Help: u16 = 0x72;
    pub(crate) const VK_Home: u16 = 0x73;
    pub(crate) const VK_PageUp: u16 = 0x74;
    pub(crate) const VK_ForwardDelete: u16 = 0x75;
    pub(crate) const VK_F4: u16 = 0x76;
    pub(crate) const VK_End: u16 = 0x77;
    pub(crate) const VK_F2: u16 = 0x78;
    pub(crate) const VK_PageDown: u16 = 0x79;
    pub(crate) const VK_F1: u16 = 0x7A;
    pub(crate) const VK_LeftArrow: u16 = 0x7B;
    pub(crate) const VK_RightArrow: u16 = 0x7C;
    pub(crate) const VK_DownArrow: u16 = 0x7D;
    pub(crate) const VK_UpArrow: u16 = 0x7E;

    /* ISO keyboards only*/
    pub(crate) const VK_ISO_Section: u16 = 0x0A;

    pub(crate) const VK_JIS_Yen: u16 = 0x5D;
    pub(crate) const VK_JIS_Underscore: u16 = 0x5E;
    pub(crate) const VK_JIS_KeypadComma: u16 = 0x5F;
    pub(crate) const VK_JIS_Eisu: u16 = 0x66;
    pub(crate) const VK_JIS_Kana: u16 = 0x68;
}
