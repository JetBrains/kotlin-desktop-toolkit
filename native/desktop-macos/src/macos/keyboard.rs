use anyhow::{Context, Ok, bail};
use objc2::rc::Retained;
use objc2_app_kit::{NSEvent, NSEventModifierFlags, NSEventType};
use objc2_foundation::{NSString, NSTimeInterval};

use super::window_api::WindowId;

#[repr(transparent)]
#[derive(Debug, Clone, Copy)]
pub struct KeyCode(u16);

#[derive(Debug)]
pub(crate) struct KeyEventInfo {
    pub(crate) window_id: WindowId,

    pub(crate) is_repeat: bool,

    // Represents physical key location
    // Isn't affected by keyboard layout, locale and pressed modifiers
    pub(crate) code: KeyCode,

    // Roughly speaking it's a text that will be generated by this key press
    // It's affected by keyboard layout locale and pressed modifiers
    // It may contain codepoint constants listed in this file,
    // e.g. for F1 it will be value of `NSF1FunctionKey` constant
    // For dead keys it will be empty
    pub(crate) chars: Retained<NSString>,

    // Can be considered as a name of the key
    // Depends on keyboard layout but ignores modifiers
    // For keys that depend on keyboard layout it will be the symbol typed for default layer
    // For functional keys it will try to produce some meaningful codepoint, but not the same as for `characters`
    // For dead keys it will produce text from deafult layer
    #[allow(dead_code)]
    pub(crate) key: Retained<NSString>,

    pub(crate) modifiers: KeyModifiersSet,

    pub(crate) timestamp: NSTimeInterval,
}

pub(crate) fn unpack_key_event(ns_event: &NSEvent) -> anyhow::Result<KeyEventInfo> {
    let window_id = unsafe { ns_event.windowNumber() };
    let is_repeat = unsafe { ns_event.isARepeat() };
    let code = unsafe { ns_event.keyCode() };

    let chars = unsafe { ns_event.characters() }.with_context(|| format!("No characters field in {ns_event:?}"))?;

    let key = unsafe { ns_event.charactersByApplyingModifiers(NSEventModifierFlags::empty()) }
        .with_context(|| format!("Event contains invalid data: {ns_event:?}"))?;

    // though we apply the same modifiers, it's not the same as characters
    // there are number of differences:
    // * for dead keys `characters` will be empty, but this string will contain symbol representing the key
    // * for for keys like F1..F12 characters will contain codepoints from private use area defined in `KeyCodePoints`,
    // but this function will try to return some meaniingful code points
    // * for all F1..F16 keys this function will return the same codepoint: \u{10} for F17 it will be empty line
    //let _with_modifiers = unsafe {
    //    ns_event.charactersByApplyingModifiers(ns_event.modifierFlags())
    //}.with_context(|| { format!("Event contains invalid data: {ns_event:?}") })?;
    let modifiers = unsafe { ns_event.modifierFlags() }.into();

    let timestamp = unsafe { ns_event.timestamp() };

    // todo unpack modifiers
    let key_info = KeyEventInfo {
        window_id,
        is_repeat,
        code: KeyCode(code),
        chars,
        key,
        modifiers,
        timestamp,
    };
    Ok(key_info)
}

#[derive(Debug)]
pub(crate) struct FlagsChangedInfo {
    pub(crate) modifiers: KeyModifiersSet,
    pub(crate) code: KeyCode,
}

pub(crate) fn unpack_flags_changed_event(ns_event: &NSEvent) -> anyhow::Result<FlagsChangedInfo> {
    if unsafe { ns_event.r#type() } != NSEventType::FlagsChanged {
        bail!("Unexpected type of event {:?}", ns_event);
    }
    let modifiers = unsafe { ns_event.modifierFlags() }.into();
    let code = unsafe { ns_event.keyCode() };

    Ok(FlagsChangedInfo {
        modifiers,
        code: KeyCode(code),
    })
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct KeyModifiersSet(usize);

impl std::fmt::Debug for KeyModifiersSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyModifiersSet({:#b})", self.0)
    }
}

pub(crate) const EMPTY_KEY_MODIFIERS: KeyModifiersSet = KeyModifiersSet(0);

impl From<NSEventModifierFlags> for KeyModifiersSet {
    fn from(value: NSEventModifierFlags) -> Self {
        Self(value.bits())
    }
}

impl From<KeyModifiersSet> for NSEventModifierFlags {
    fn from(value: KeyModifiersSet) -> Self {
        Self(value.0)
    }
}
