use std::ffi::CString;

use anyhow::{bail, Context, Ok};
use objc2::rc::autoreleasepool;
use objc2_app_kit::{NSEvent, NSEventModifierFlags, NSEventType};

#[repr(transparent)]
#[derive(Debug, Clone, Copy)]
pub struct KeyCode(u16);

#[allow(dead_code)]
#[derive(Debug)]
pub(crate) struct KeyEventInfo {
    pub(crate) is_press: bool,
    pub(crate) is_repeat: bool,

    // Represents physical key location
    // Isn't affected by keyboard layout, locale and pressed modifiers
    pub(crate) code: KeyCode,

    // Roughly speaking it's a text that will be generated by this key press
    // It's affected by keyboard layout locale and pressed modifiers
    // It may contain codepoint constants listed in this file,
    // e.g. for F1 it will be value of `NSF1FunctionKey` constant
    // For dead keys it will be empty
    pub(crate) chars: CString,

    // Can be considered as a name of the key
    // Depends on keyboard layout but ignores modifiers
    // For keys that depend on keyboard layout it will be the symbol typed for default layer
    // For functional keys it will try to produce some meaningful codepoint, but not the same as for `characters`
    // For dead keys it will produce text from deafult layer
    pub(crate) key: CString,

    pub(crate) modifiers: KeyModifiersSet,
}

pub(crate) fn unpack_key_event(ns_event: &NSEvent) -> anyhow::Result<KeyEventInfo> {
    autoreleasepool(|pool| {
        let is_press = match unsafe { ns_event.r#type() } {
            NSEventType::KeyDown => true,
            NSEventType::KeyUp => false,
            _ => bail!("Unexpected type of event {:?}", ns_event),
        };

        let is_repeat = unsafe { ns_event.isARepeat() };
        let code = unsafe { ns_event.keyCode() };

        let chars = unsafe { ns_event.characters() }.with_context(|| format!("No characters field in {ns_event:?}"))?;

        let key = unsafe { ns_event.charactersByApplyingModifiers(NSEventModifierFlags::empty()) }
            .with_context(|| format!("Event contains invalid data: {ns_event:?}"))?;

        // though we apply the same modifiers, it's not the same as characters
        // there are number of differences:
        // * for dead keys `characters` will be empty, but this string will contain symbol representing the key
        // * for for keys like F1..F12 characters will contain codepoints from private use area defined in `KeyCodePoints`,
        // but this function will try to return some meaniingful code points
        // * for all F1..F16 keys this function will return the same codepoint: \u{10} for F17 it will be empty line
        //let _with_modifiers = unsafe {
        //    ns_event.charactersByApplyingModifiers(ns_event.modifierFlags())
        //}.with_context(|| { format!("Event contains invalid data: {ns_event:?}") })?;

        let chars = CString::new(unsafe { chars.to_str(pool) }).unwrap_or_default(/* to handle e.g. Ctrl+Space */);
        let key = CString::new(unsafe { key.to_str(pool) }).with_context(|| format!("{key:?}"))?;

        let modifiers = unsafe { ns_event.modifierFlags() }.into();

        // todo unpack modifiers
        let key_info = KeyEventInfo {
            is_press,
            is_repeat,
            code: KeyCode(code),
            chars,
            key,
            modifiers,
        };
        Ok(key_info)
    })
}

#[derive(Debug)]
pub(crate) struct FlagsChangedInfo {
    pub(crate) modifiers: KeyModifiersSet,
    pub(crate) code: KeyCode,
}

pub(crate) fn unpack_flags_changed_event(ns_event: &NSEvent) -> anyhow::Result<FlagsChangedInfo> {
    if unsafe { ns_event.r#type() } != NSEventType::FlagsChanged {
        bail!("Unexpected type of event {:?}", ns_event);
    }
    let modifiers = unsafe { ns_event.modifierFlags() }.into();
    let code = unsafe { ns_event.keyCode() };

    Ok(FlagsChangedInfo {
        modifiers,
        code: KeyCode(code),
    })
}

#[derive(Debug, Clone, Copy)]
#[repr(transparent)]
pub struct KeyModifiersSet(usize);

pub(crate) const EMPTY_KEY_MODIFIERS: KeyModifiersSet = KeyModifiersSet(0);

impl From<NSEventModifierFlags> for KeyModifiersSet {
    fn from(value: NSEventModifierFlags) -> Self {
        Self(value.bits())
    }
}

impl From<&KeyModifiersSet> for NSEventModifierFlags {
    fn from(value: &KeyModifiersSet) -> Self {
        Self(value.0)
    }
}
